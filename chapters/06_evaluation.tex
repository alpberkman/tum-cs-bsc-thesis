% !TeX root = ../main.tex

% Evaluation
% Explain the high-level research questions
% Experimental testbed, benchmarks, methodology
% Evaluate the research questions/hypotheses
\chapter{Evaluation}\label{chapter:evaluation}
In this chapter, we will discuss how we tested the reproducer and how well it met our initial goals.
We have selected around 10 bugs from \ac{QEMU}'s GitLab repository, each with programs known to trigger them.
We will go over the bugs we have tried to recreate and see how our results stack up against the original programs. 
We will also go over the foundation of the reproducer, namely Miasm, and explain its importance.

\section{Experimental Testbed}
In the testing phase of our project, our goal was to trigger the same errors as the original code.
This meant when we ran the verifier with the reproducer binary, the output should match with the original program.
The testing process is made up of 5 steps:
\begin{itemize}
    \item Obtain the symbolic log from the original program's execution on the guest architecture (x86).
    \item Launch \ac{QEMU} on the host machine and capture the emulator's trace.
    \item Run the verifier to identify bugs.
    \item Repeat the same process using the code generated by the reproducer.
    \item Compare the output of the reproducer's binary with the output of the original binary.
\end{itemize}

If the outputs match, it indicates that we have successfully replicated the bug.
There may be minor differences in address values due to how memory is allocated, but the verifier should still pinpoint the problematic instruction.
This approach helps us evaluate the effectiveness of the reproducer.

\section{Example Test Case}
In this section, we will go over a concrete example to demonstrate how our program fares against the original reproducers we have found in GitLab.
One of the bugs that we encountered was related to the cmpxchg instruction.
Here we will go over this bug and its original reproducer.
The original reproducer code is shown in figure \ref{fig:c}.
It was written in C with inline assembly.
This program itself is already written as a reproducer, meaning it was designed just to trigger this bug and it doesn't do anything else.
If this program is used along with the reproducer the output will look like in figure \ref{fig:gas}.

\begin{figure}[ht]
    \centering
    \begin{minted}{c}
        #include <stdio.h>

        int main() {
          int mem = 0x12345678;
          register long rax asm("rax") = 0x1234567812345678;
          register int edi asm("edi") = 0x77777777;
          asm("cmpxchg %[edi],%[mem]"
              : [ mem ] "+m"(mem), [ rax ] "+r"(rax)
              : [ edi ] "r"(edi));
          long rax2 = rax;
          printf("rax2 = %lx\n", rax2);
        }
    \end{minted}
    \caption{Original reproducer program for the cmpxchg instruction with inline assembly.}
    \label{fig:c}
\end{figure}

\begin{figure}[ht]
    \centering
    \begin{minted}{gas}       
        .section .text
        .global _start
        
        _start:
        
        _stack:
        mov ax, 0x1234
        push ax
        mov ax, 0x5678
        push ax
        mov ax, 0x0000
        push ax
        mov ax, 0x0000
        push ax
        sub rsp, 0
        
        _setup_regs:
        mov rdi, 0x77777777
        mov rax, 0x1234567812345678
        
        _bb:
        cmpxchg dword ptr [rsp + 0x4], edi
        
        _exit:
        mov rax, 60
        mov rdi, 0
        syscall
    \end{minted}
    \caption{Shortened output of the reproducer for the cmpxchg instruction.}
    \label{fig:gas}
\end{figure}

As is visible the output is in assembly instructions and is quite minimal.
It just sets the stack and the registers, executes the instruction, and then exits.
Since all this program does is trigger the error, it is quite smaller than the original reproducer, which is already supposed to be a minimal example.

\begin{table}[htpb]
    \caption[Log size comparision]{Size comparision of various logs.}\label{tab:log}
    \centering
    \begin{tabular}{l r r r}
      \toprule
        Reproducer & Binary Size & Symbolic Trace Size & Emulator Log Size \\
      \midrule
        Original & 30,4 KiB & 1,4 MiB & 484,1 KiB \\
        Automatically Generated & 4,8 KiB & 23,0 KiB & 3,5 KiB \\
      \bottomrule
    \end{tabular}
\end{table}

The comparison of various logs can be seen in table \ref{tab:log}.
First of all the binary size of our program is less than one-sixth of the original program.
This size reduction can be attributed to not linking the \ac{clib} to our program since we don't use printf, unlike the original code.
This demonstrates how our program effectively eliminates most of the non-essential code from the given program.

This efficiency has additional advantages in program analysis.
The symbolic trace of our program is significantly smaller than the original's.
This reduction results from avoiding the execution of unnecessary instructions.
Since a symbolic trace consists of changes in registers and memory, minimizing instruction execution means fewer changes occur.
Similarly, the emulator log for our program is much shorter than the original's.
To quantify, the symbolic trace of our program is about 1/57th the size of the original, and the emulator log is about 1/122nd the size.
This illustrates the effectiveness of our reproducer at minimizing the workload in the analysis of results.



\section{Testing on Larger Scale}
In the introduction to this section, we mentioned our attempt to replicate around 10 bugs.
We have chosen these bugs because they already had reproducer programs that we could use to test our reproducer.
This testing required compiling an older version of \ac{QEMU}, gathering traces, and comparing the outputs.
However, we soon discovered that reproducing most of the bugs was not feasible.
While Miasm supports many common instructions, it lacks proper implementation for some of the more niche instructions.
However, these instructions are often more prone to errors.
As a result, the verifier was unable to identify the faulty instructions; they were either overlooked, misinterpreted, or incorrectly translated.
This issue highlighted our program's reliance on Miasm having comprehensive instruction support.
Unfortunately, due to these limitations, we were unable to test bugs involving less common instructions.

\section{Results}
To sum up the results of our experiments, we can say that the reproducer works for some cases but its functionality is limited by the verifier, which in turn depends on Miasm.
There is no simple way to fix this except to implement the missing operations in Miasm or to use a different symbolic execution engine.
However changing the basis of the verifier is not a simple task and even if we were to use a different symbolic execution engine, there would be no guarantee that it would also not miss any instruction.

But when the instructions are implemented and our reproducer works, it can create simple assembly programs that can trigger the same bugs.
Since these programs bundle the bugs with a minimal amount of setup they are simpler to test.
This should show that our program can be used to improve the development cycle of emulator developers as a tool that can simplify the debugging process.


In summary, our experiments show that the reproducer is effective in certain situations, but its functionality is limited by the verifier, which, in turn, relies on Miasm.
The only straightforward solutions are to fill in Miasm's missing operations or switch to a different symbolic execution engine.
However, changing the foundation of the verifier is a complex endeavor, and opting for another engine doesn't guarantee it would cover all instructions either.
In that sense only feasible option is to add the missing operations to Miasm.
But unless we do this for every instruction, we cannot be sure that it really works.
Adding support for every missing instruction is a very difficult task, as it either requires a tremendous amount of knowledge in the x86 architecture or reading the manual, which is also error-prone. 

Despite these challenges, when the bugs occur in supported instructions, our reproducer successfully generates simple assembly programs that replicate the original bugs.
These programs, designed with minimal setup, are easier to test, demonstrating the potential of our tool to streamline the development and debugging processes for emulator developers.

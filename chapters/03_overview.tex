% !TeX root = ../main.tex

% Overview
% Explain the system overview
% Design goals
% Explain the system workflow
% Identify system components and explain their function
\chapter{Overview}\label{chapter:overview}
In this chapter, we aim to provide a clear overview of our project, outlining its progression, design goals, and the its key components.
We'll begin by discussing the shifts in direction that the project has taken, due our new insights
This reflection is quite important as we have came to notice that our first assumption was erroneous.
Next, we will talk a bit bout the design goals when extending the verifer.
Following this, we will give an overview of how the whole verifier/reproducer combination works along with how individual components function.
To wrap up the chapter, we will present a survey and an analysis of common bugs found in Qemu.

\section{Course of the Project}
We started this project with the primary goal of evaluating the accuracy and reliability of various emulators.
This entailed a research in common emulator bugs along with recreating them.
Our main targets were Qemu and Arancini but we designed to make it as generic as possible.
In order for other emulators to work with the reproducer they just need to fulfill some basic requirements.

Our part on this project was focused on the developing a program that could produce tests by utilizing symbolic execution on erroneous programs.
Initially, our assumption was that a significant proportion of the flaws and inconsistencies discovered in Qemu could be attributed to issues within the Tiny Code Generator.

Specifically, we suspected that these bugs were a result of erroneous execution paths that led to incorrect jumps within the code. To address this, we planned to use symbolic execution to construct a tree.
This tree was intended to serve as a map, guiding us through execution path and therefore identifying these incorrect jumps.

Through this method we had hoped to:
\begin{enumerate}[label=(\Alph*)]
   \item Find the shortest path to the error
   \item Recreate the the erroneous program by changing the inputs and making sure that it would follow the aforementioned path
   \item Use fuzzing to create multiple tests, and therefore increase the chance to find additional bugs
\end{enumerate}

Through this method, we had hoped to automate test generation and simplfy finding bugs in emulators.
However we came to notice that most of the bugs stemming from Tiny Code Generator are not because of incorrect jumps, they were in fact caused by wrong implementation of instructions.
Because of these findings our project had a slight change of direction.

Because of our new findings we stopped concentrating on following the erroneous path and instead concentrated on the offending instruction.
Considering that most of the hard to find bugs are stemming not from the general functionality but the edge cases, we came to the understanding that we need to recreate the state where this bug occured.
This meant we needed to sample the memory and registers before the erroneous instruction.
We used symbolic execution to find the symbolic expressions that were used in the instruction and then used concrete values to recreate a similar state.
By combining these values, the offending instruction and other code stubs that are used for running code, we managed to recreate a tiny executable that can cause the same bug.

\section{Design Goals}
With the reproducer our main goal was to extract bugs in the simplest manner possible.
This means the reproducer shoudn't require any additional data beyond what the verifier supplies.
It utilizes the provided symbolic traces and concrete values to replicate the bug.
Another key aim is to offer users flexibility.
Instead of generating a binary, the reproducer outputs assembly instructions.
This allows users to both see the problematic instruction directly or, if they prefer, compile it into a binary using an assembler of their choice.

\section{System Workflow and Component's Functions}
The reproducer is designed as an add-on to the Focaccia.
Much of its functionality relies on this verifier.

\subsection{Inputs}
Both the verifier and the reproducer use the same two inputs, namely the emulator log and the binary.
However there are some pecularities for both of them.
The first one is the emulator log, which can be structured in any way, as long as it contains necessary information.
These logs should either document every change in memory and register values based on the program counter \ac{PC} or provide complete snapshots of memory and register states at each PC.
These are necessary as Focaccia relies on these logs to accurately replicate the emulator's actions.

Also the logs we use must come from binaries that are statically linked, not dynamically linked.
This ensures that the program runs with the same set of instructions, regardless of the environment it's executed in.
For instance, discrepancies in the \ac{clib}, whether due to different libraries or versions, can lead to varied instructions.
Such variations would cause the traces to not align, resulting in a trace output filled with errors unrelated to the actual faulty instruction.

\subsection{First Component: Focaccia the Verifier}

Focaccia is the verifier that we are using to detect erros in the emulators.
It functions by comparing an emulator with an oracle.
It uses the Miasm reverse engineering framework and the LLDB debugger from LLVM. 
There are two inputs required for the verification, namely the emulator log and the binary.
Firstly, Focaccia analyzes the instructions in the binary to generate a symbolic trace.
This trace maps out all modifications in memory, registers, and branches, effectively creating a tree-like structure that outlines potential changes for each instruction.
However, this symbolic trace isn't sufficient on its own. 
The binary also provides concrete values, from which Focaccia takes snapshots.
Later these transformations are comapred with the emulator log.
Then it compares the transformations and finds wheter there is a mismatch between different states.

\subsection{Second Component: the Reproducer}
The reproducer is an add-on to the verifier, with its role being to prepare the assembly instructions needed for triggering a specific bug. 
If enabled by the verifier, it will be run after the verification process is done and the erroneous instructions are found.
After the verifier finishes collecting the snapshots and the symbolic expressions.
It is filtered for discrepancies and if found it is passed to the reproducer as shown in figure \ref{fig:ver_and_rep_1}.
After the reproducer receives the inputs, it will then try to extract only the necessary data from the snapshot which will be bundled with other assembly instructions.
This output is significant as it not only points out which instruction is erroneous but also demonstrates the conditions under which the bug occurs.
Ultimately it should make debugging by recreating both the environment and the instruction.

\begin{figure}[ht]
   \centering
   \includegraphics[width=0.4\linewidth]{figures/ver_and_rep_1}
   \caption{Overview of the verifier and the reproducer}
   \label{fig:ver_and_rep_1}
\end{figure}

\section{Survey of Qemu Bugs}
TODO
